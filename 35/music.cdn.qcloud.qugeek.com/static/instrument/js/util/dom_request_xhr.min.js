'use strict';
"undefined" == typeof MIDI && (MIDI = {}), function(root) {
  if ((root.util || (root.util = {})).request = function(opts, onsuccess, onerror, onprogress) {
    if ("string" == typeof opts) {
      opts = {
        url : opts
      };
    }
    var body = opts.data;
    /** @type {string} */
    var url = opts.url;
    var name = opts.method || (opts.data ? "POST" : "GET");
    var undefined = opts.format;
    var headers = opts.headers;
    var responseType = opts.responseType;
    var f = opts.withCredentials || false;
    onsuccess = onsuccess || opts.onsuccess;
    onerror = onerror || opts.onerror;
    onprogress = onprogress || opts.onprogress;
    if (void 0 === fs || !root.loc.isLocalUrl(url)) {
      /** @type {!XMLHttpRequest} */
      var xhr = new XMLHttpRequest;
      if (xhr.open(name, url, true), headers) {
        var i;
        for (i in headers) {
          xhr.setRequestHeader(i, headers[i]);
        }
      } else {
        if (body) {
          xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
      }
      return "binary" === undefined && xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=x-user-defined"), responseType && (xhr.responseType = responseType), f && (xhr.withCredentials = "true"), onerror && "onerror" in xhr && (xhr.onerror = onerror), onprogress && xhr.upload && "onprogress" in xhr.upload && (body ? xhr.upload.onprogress = function(evt) {
        onprogress.call(xhr, evt, event.loaded / event.total);
      } : xhr.addEventListener("progress", function(evt) {
        /** @type {number} */
        var totalBytes = 0;
        if (evt.lengthComputable) {
          totalBytes = evt.total;
        } else {
          if (xhr.totalBytes) {
            totalBytes = xhr.totalBytes;
          } else {
            /** @type {number} */
            var rawBytes = parseInt(xhr.getResponseHeader("Content-Length-Raw"));
            if (!isFinite(rawBytes)) {
              return;
            }
            /** @type {number} */
            xhr.totalBytes = totalBytes = rawBytes;
          }
        }
        onprogress.call(xhr, evt, evt.loaded / totalBytes);
      })), xhr.onreadystatechange = function(evt) {
        if (4 === xhr.readyState) {
          if (200 === xhr.status || 304 === xhr.status || 308 === xhr.status || 0 === xhr.status && root.client.cordova) {
            if (onsuccess) {
              var res;
              if ("xml" === undefined) {
                res = evt.target.responseXML;
              } else {
                if ("text" === undefined) {
                  res = evt.target.responseText;
                } else {
                  if ("json" === undefined) {
                    try {
                      /** @type {*} */
                      res = JSON.parse(evt.target.response);
                    } catch (e) {
                      if (onerror) {
                        onerror.call(xhr, evt);
                      }
                    }
                  }
                }
              }
              onsuccess.call(xhr, evt, res);
            }
          } else {
            if (onerror) {
              onerror.call(xhr, evt);
            }
          }
        }
      }, xhr.send(body), xhr;
    }
    fs.readFile(url, "utf8", function(e, data) {
      if (e) {
        if (onerror) {
          onerror(e);
        }
      } else {
        if (onsuccess) {
          onsuccess({
            responseText : data
          });
        }
      }
    });
  }, "undefined" != typeof module && module.exports) {
    var fs = require("fs");
    XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
    module.exports = root.util.request;
  }
}(MIDI);
